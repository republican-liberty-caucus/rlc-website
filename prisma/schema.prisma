// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// ===========================================
// Enums
// ===========================================

enum MembershipTier {
  student_military
  individual
  premium
  sustaining
  patron
  benefactor
  roundtable
}

enum MembershipStatus {
  new_member  // "new" is reserved in SQL, so we use new_member in Prisma but map to "new" in app logic
  current
  grace
  expired
  pending
  cancelled
  deceased
  expiring
}

enum ContributionType {
  membership
  donation
  event_registration
  merchandise
}

enum PaymentStatus {
  pending
  completed
  failed
  refunded
  cancelled
}

enum CharterLevel {
  national
  multi_state_region
  state
  intra_state_region
  county
}

enum CharterStatus {
  active
  inactive
  forming
}

enum HouseholdRole {
  primary
  spouse
  child
}

enum UserRole {
  member
  charter_officer
  charter_admin
  state_chair
  regional_coordinator
  national_board
  super_admin
}

// Phase 4 enums (backfill — tables already exist)

enum SurveyStatus {
  draft
  active
  closed
}

enum CandidateResponseStatus {
  pending
  in_progress
  submitted
  endorsed
  not_endorsed
}

enum QuestionType {
  scale
  yes_no
  text
  multiple_choice
}

// Phase 5 enums

enum Jurisdiction {
  federal
  state
}

enum ScorecardSessionStatus {
  draft
  active
  published
  archived
}

enum LibertyPosition {
  yea
  nay
}

enum BillTrackingStatus {
  tracking
  voted
  no_vote
}

enum VoteChoice {
  yea
  nay
  not_voting
  absent
  present
  not_applicable
}

enum SponsorshipRole {
  sponsor
  cosponsor
}

enum LegislativeChamber {
  us_house
  us_senate
  state_house
  state_senate
}

enum CampaignStatus {
  draft
  active
  completed
  cancelled
}

// Dues Sharing enums

enum DisbursementModel {
  national_managed
  state_managed
}

enum StripeConnectStatus {
  not_started
  onboarding
  active
  disabled
}

enum SplitLedgerStatus {
  pending
  processing
  transferred
  reversed
  failed
}

enum SplitSourceType {
  membership
  donation
  event_registration
}

// Candidate Vetting enums

enum VettingStage {
  survey_submitted
  auto_audit
  assigned
  research
  interview
  committee_review
  board_vote
}

enum VettingReportSectionType {
  digital_presence_audit
  executive_summary
  election_schedule
  voting_rules
  candidate_background
  incumbent_record
  opponent_research
  electoral_results
  district_data
}

enum AuditStatus {
  audit_pending
  running
  audit_completed
  audit_failed
}

enum VettingRecommendation {
  endorse
  do_not_endorse
  no_position
}

enum VettingSectionStatus {
  section_not_started
  section_assigned
  section_in_progress
  section_completed
  needs_revision
}

enum BoardVoteChoice {
  vote_endorse
  vote_do_not_endorse
  vote_no_position
  vote_abstain
}

enum CommitteeRole {
  chair
  committee_member
}

// Office type classification
enum OfficeLevel {
  federal
  state
  county
  municipal
  judicial
  special_district
}

// ===========================================
// Core Tables
// ===========================================

/// Organizational hierarchy (self-referential)
model Charter {
  id               String        @id @default(uuid())
  name             String
  slug             String        @unique
  charterLevel     CharterLevel  @map("charter_level")
  parentCharterId  String?       @map("parent_charter_id")
  parent           Charter?      @relation("CharterHierarchy", fields: [parentCharterId], references: [id])
  children         Charter[]     @relation("CharterHierarchy")
  stateCode        String?       @map("state_code") @db.Char(2)
  regionName       String?       @map("region_name")
  status           CharterStatus @default(active)
  websiteUrl       String?       @map("website_url")
  contactEmail     String?       @map("contact_email")
  description      String?       @db.Text
  contactPhone     String?       @map("contact_phone") @db.VarChar(20)
  facebookUrl      String?       @map("facebook_url")
  twitterUrl       String?       @map("twitter_url")
  bylawsUrl        String?       @map("bylaws_url")
  leadership       Json          @default("{}")
  metadata         Json          @default("{}")
  createdAt        DateTime      @default(now()) @map("created_at")
  updatedAt        DateTime      @updatedAt @map("updated_at")

  // Relations
  contacts           Contact[]
  contactRoles       ContactRole[]
  contributions      Contribution[]
  events             Event[]
  posts              Post[]
  surveys            Survey[]
  scorecardSessions  ScorecardSession[]
  actionCampaigns    ActionCampaign[]

  // Dues sharing relations
  stripeAccount        CharterStripeAccount?
  splitConfig          CharterSplitConfig?
  splitRulesAsRecipient CharterSplitRule[]   @relation("SplitRuleRecipient")
  splitLedgerEntries   SplitLedgerEntry[]    @relation("LedgerRecipient")

  @@map("rlc_charters")
}

/// Contacts (everyone in the database - synced with Clerk users)
model Contact {
  id                   String           @id @default(uuid())
  clerkUserId          String?          @unique @map("clerk_user_id")
  email                String?          @unique
  firstName            String           @map("first_name")
  lastName             String           @map("last_name")
  phone                String?
  addressLine1         String?          @map("address_line1")
  addressLine2         String?          @map("address_line2")
  city                 String?
  state                String?
  postalCode           String?          @map("postal_code")
  country              String           @default("US")

  // Membership
  membershipTier       MembershipTier   @default(individual) @map("membership_tier")
  membershipStatus     MembershipStatus @default(pending) @map("membership_status")
  membershipStartDate  DateTime?        @map("membership_start_date")
  membershipExpiryDate DateTime?        @map("membership_expiry_date")
  membershipJoinDate   DateTime?        @map("membership_join_date")

  // Charter affiliation
  primaryCharterId     String?          @map("primary_charter_id")
  primaryCharter       Charter?         @relation(fields: [primaryCharterId], references: [id])

  // External IDs
  highlevelContactId   String?          @unique @map("highlevel_contact_id")
  civicrmContactId     Int?             @unique @map("civicrm_contact_id")
  stripeCustomerId     String?          @unique @map("stripe_customer_id")

  // Preferences
  emailOptIn           Boolean          @default(true) @map("email_opt_in")
  smsOptIn             Boolean          @default(false) @map("sms_opt_in")
  doNotPhone           Boolean          @default(false) @map("do_not_phone")

  // Email validation (Reoon)
  emailValidatedAt     DateTime?        @map("email_validated_at")
  emailStatus          String?          @map("email_status")
  emailOverallScore    Int?             @map("email_overall_score")
  emailIsSafeToSend    Boolean?         @map("email_is_safe_to_send")
  emailIsValidSyntax   Boolean?         @map("email_is_valid_syntax")
  emailIsDisposable    Boolean?         @map("email_is_disposable")
  emailIsRoleAccount   Boolean?         @map("email_is_role_account")
  emailIsSpamtrap      Boolean?         @map("email_is_spamtrap")
  emailIsFreeEmail     Boolean?         @map("email_is_free_email")
  emailIsDeliverable   Boolean?         @map("email_is_deliverable")
  emailIsCatchAll      Boolean?         @map("email_is_catch_all")
  emailMxAcceptsMail   Boolean?         @map("email_mx_accepts_mail")

  // Household / family members
  householdId          String?          @map("household_id")
  householdRole        HouseholdRole?   @map("household_role")
  primaryContactId     String?          @map("primary_contact_id")
  primaryContact       Contact?         @relation("HouseholdContacts", fields: [primaryContactId], references: [id])
  householdContacts    Contact[]        @relation("HouseholdContacts")

  metadata             Json             @default("{}")
  createdAt            DateTime         @default(now()) @map("created_at")
  updatedAt            DateTime         @updatedAt @map("updated_at")

  // Relations
  memberships             Membership[]     @relation("ContactMemberships")
  roles                   ContactRole[]    @relation("ContactRoles")
  grantedRoles            ContactRole[]    @relation("GrantedRoles")
  contributions           Contribution[]
  organizedEvents         Event[]
  eventRegistrations      EventRegistration[]
  posts                   Post[]
  surveysCreated          Survey[]           @relation("SurveyCreator")
  scorecardSessionsCreated ScorecardSession[] @relation("ScorecardCreator")
  campaignsCreated        ActionCampaign[]   @relation("CampaignCreator")
  campaignParticipations  CampaignParticipation[]

  // Dues sharing relations
  splitConfigsUpdated    CharterSplitConfig[] @relation("SplitConfigUpdater")

  // Candidate vetting relations
  committeeMembers          CandidateVettingCommitteeMember[]
  vettingSectionAssignments CandidateVettingSectionAssignment[]
  boardVotes                CandidateVettingBoardVote[]
  digitalAuditsTriggered    CandidateDigitalAudit[]           @relation("AuditTriggeredBy")

  @@map("rlc_members")
}

/// Membership records (1-to-many with Contact for membership history)
model Membership {
  id                   String           @id @default(uuid())
  contactId            String           @map("contact_id")
  contact              Contact          @relation("ContactMemberships", fields: [contactId], references: [id], onDelete: Cascade)
  membershipTier       MembershipTier   @map("membership_tier")
  membershipStatus     MembershipStatus @map("membership_status")
  startDate            DateTime?        @map("start_date")
  expiryDate           DateTime?        @map("expiry_date")
  joinDate             DateTime?        @map("join_date")
  amount               Decimal?         @db.Decimal(10, 2)
  currency             String?          @default("USD")
  civicrmMembershipId  Int?             @unique @map("civicrm_membership_id")
  isAutoRenew          Boolean          @default(false) @map("is_auto_renew")
  stripeSubscriptionId String?          @map("stripe_subscription_id")
  metadata             Json             @default("{}")
  createdAt            DateTime         @default(now()) @map("created_at")
  updatedAt            DateTime         @updatedAt @map("updated_at")

  @@index([contactId])
  @@index([membershipStatus])
  @@index([expiryDate])
  @@map("rlc_memberships")
}

/// Contact roles (multi-role support)
model ContactRole {
  id          String    @id @default(uuid())
  contactId   String    @map("contact_id")
  contact     Contact   @relation("ContactRoles", fields: [contactId], references: [id], onDelete: Cascade)
  role        UserRole
  charterId   String?   @map("charter_id")
  charter     Charter?  @relation(fields: [charterId], references: [id])
  grantedById String?   @map("granted_by")
  grantedBy   Contact?  @relation("GrantedRoles", fields: [grantedById], references: [id])
  grantedAt   DateTime  @default(now()) @map("granted_at")
  expiresAt   DateTime? @map("expires_at")

  @@unique([contactId, role, charterId])
  @@map("rlc_member_roles")
}

/// Contributions/Donations
model Contribution {
  id                    String           @id @default(uuid())
  contactId             String?          @map("contact_id")
  contact               Contact?         @relation(fields: [contactId], references: [id])
  contributionType      ContributionType @map("contribution_type")
  amount                Decimal          @db.Decimal(10, 2)
  currency              String           @default("USD")

  // Payment details
  stripePaymentIntentId String?          @map("stripe_payment_intent_id")
  stripeSubscriptionId  String?          @map("stripe_subscription_id")
  paymentStatus         PaymentStatus    @default(pending) @map("payment_status")
  paymentMethod         String?          @map("payment_method")

  // Attribution
  charterId             String?          @map("charter_id")
  charter               Charter?         @relation(fields: [charterId], references: [id])
  campaignId            String?          @map("campaign_id")

  // For recurring
  isRecurring           Boolean          @default(false) @map("is_recurring")
  recurringInterval     String?          @map("recurring_interval")

  // CiviCRM migration reference
  civicrmContributionId Int?             @unique @map("civicrm_contribution_id")
  transactionId         String?          @map("transaction_id")
  source                String?

  metadata              Json             @default("{}")
  createdAt             DateTime         @default(now()) @map("created_at")

  // Relations
  eventRegistrations    EventRegistration[]
  splitLedgerEntries    SplitLedgerEntry[]

  @@map("rlc_contributions")
}

/// Events
model Event {
  id                   String    @id @default(uuid())
  title                String
  slug                 String    @unique
  description          String?   @db.Text
  featuredImageUrl     String?   @map("featured_image_url")
  eventType            String?   @map("event_type")

  // Timing
  startDate            DateTime  @map("start_date")
  endDate              DateTime? @map("end_date")
  timezone             String    @default("America/New_York")

  // Location
  isVirtual            Boolean   @default(false) @map("is_virtual")
  locationName         String?   @map("location_name")
  address              String?
  city                 String?
  state                String?
  postalCode           String?   @map("postal_code")
  virtualUrl           String?   @map("virtual_url")

  // Registration
  registrationRequired Boolean   @default(true) @map("registration_required")
  maxAttendees         Int?      @map("max_attendees")
  registrationFee      Decimal?  @map("registration_fee") @db.Decimal(10, 2)
  registrationDeadline DateTime? @map("registration_deadline")

  // Ownership
  charterId            String?   @map("charter_id")
  charter              Charter?  @relation(fields: [charterId], references: [id])
  organizerId          String?   @map("organizer_id")
  organizer             Contact?   @relation(fields: [organizerId], references: [id])

  status               String    @default("draft")
  metadata             Json      @default("{}")
  createdAt            DateTime  @default(now()) @map("created_at")
  updatedAt            DateTime  @updatedAt @map("updated_at")

  // Relations
  registrations        EventRegistration[]

  @@map("rlc_events")
}

/// Event Registrations
model EventRegistration {
  id                 String        @id @default(uuid())
  eventId            String        @map("event_id")
  event              Event         @relation(fields: [eventId], references: [id], onDelete: Cascade)
  contactId          String?       @map("contact_id")
  contact            Contact?      @relation(fields: [contactId], references: [id])

  // For non-member registrations
  guestEmail         String?       @map("guest_email")
  guestName          String?       @map("guest_name")

  registrationStatus String        @default("registered") @map("registration_status")
  checkedInAt        DateTime?     @map("checked_in_at")

  // Payment
  contributionId     String?       @map("contribution_id")
  contribution       Contribution? @relation(fields: [contributionId], references: [id])

  metadata           Json          @default("{}")
  createdAt          DateTime      @default(now()) @map("created_at")

  @@map("rlc_event_registrations")
}

/// Content/Blog Posts
model Post {
  id               String    @id @default(uuid())
  title            String
  slug             String    @unique
  content          String?   @db.Text
  excerpt          String?   @db.Text
  featuredImageUrl String?   @map("featured_image_url")

  authorId         String?   @map("author_id")
  author           Contact?   @relation(fields: [authorId], references: [id])
  charterId        String?   @map("charter_id")
  charter          Charter?  @relation(fields: [charterId], references: [id])

  status           String    @default("draft")
  contentType      String    @default("post") @map("content_type") @db.VarChar(20)
  publishedAt      DateTime? @map("published_at")

  categories       String[]
  tags             String[]

  seoTitle         String?   @map("seo_title")
  seoDescription   String?   @map("seo_description")

  metadata         Json      @default("{}")
  createdAt        DateTime  @default(now()) @map("created_at")
  updatedAt        DateTime  @updatedAt @map("updated_at")

  @@map("rlc_posts")
}

/// HighLevel Sync Log
model HighLevelSyncLog {
  id              String   @id @default(uuid())
  entityType      String   @map("entity_type")
  entityId        String   @map("entity_id")
  highlevelId     String?  @map("highlevel_id")
  action          String
  status          String   @default("pending")
  errorMessage    String?  @map("error_message") @db.Text
  requestPayload  Json?    @map("request_payload")
  responsePayload Json?    @map("response_payload")
  createdAt       DateTime @default(now()) @map("created_at")

  @@map("rlc_highlevel_sync_log")
}

/// CiviCRM Migration Tracking
model CiviCRMMigrationLog {
  id           String    @id @default(uuid())
  entityType   String    @map("entity_type")
  civicrmId    Int       @map("civicrm_id")
  supabaseId   String?   @map("supabase_id")
  status       String    @default("pending")
  errorMessage String?   @map("error_message") @db.Text
  migratedAt   DateTime? @map("migrated_at")

  @@unique([entityType, civicrmId])
  @@map("rlc_civicrm_migration_log")
}

// ===========================================
// Phase 4: Candidate Surveys (backfill — tables already exist in DB)
// ===========================================

/// Candidate Endorsement Surveys
model Survey {
  id            String       @id @default(uuid())
  title         String
  slug          String       @unique
  description   String?      @db.Text
  status        SurveyStatus @default(draft)
  electionType  String?      @map("election_type")
  electionDate  String?      @map("election_date")
  state         String?
  charterId     String?      @map("charter_id")
  charter       Charter?     @relation(fields: [charterId], references: [id])
  createdBy     String?      @map("created_by")
  creator          Contact?      @relation("SurveyCreator", fields: [createdBy], references: [id])
  createdAt     DateTime     @default(now()) @map("created_at")
  updatedAt     DateTime     @updatedAt @map("updated_at")

  questions     SurveyQuestion[]
  candidates    CandidateResponse[]

  @@map("rlc_surveys")
}

/// Survey Questions
model SurveyQuestion {
  id           String       @id @default(uuid())
  surveyId     String       @map("survey_id")
  survey       Survey       @relation(fields: [surveyId], references: [id], onDelete: Cascade)
  questionText String       @map("question_text")
  questionType QuestionType @map("question_type")
  options      String[]
  weight       Decimal      @default(1) @db.Decimal(3, 1)
  sortOrder    Int          @default(0) @map("sort_order")
  idealAnswer  String?      @map("ideal_answer")
  createdAt    DateTime     @default(now()) @map("created_at")

  answers      SurveyAnswer[]

  @@map("rlc_survey_questions")
}

/// Reference table of structured office/race types
model OfficeType {
  id                    String       @id @default(uuid())
  level                 OfficeLevel
  name                  String       // "US Senate", "State House / Assembly"
  slug                  String       @unique
  endorsingCharterLevel CharterLevel @map("endorsing_charter_level")
  requiresState         Boolean      @default(true) @map("requires_state")
  requiresDistrict      Boolean      @default(false) @map("requires_district")
  requiresCounty        Boolean      @default(false) @map("requires_county")
  districtLabel         String?      @map("district_label") // "District", "Ward", "Seat", "Precinct", "Circuit"
  sortOrder             Int          @default(0) @map("sort_order")
  isActive              Boolean      @default(true) @map("is_active")
  createdAt             DateTime     @default(now()) @map("created_at")
  updatedAt             DateTime     @updatedAt @map("updated_at")

  candidateResponses CandidateResponse[]
  candidateVettings  CandidateVetting[]

  @@map("rlc_office_types")
}

/// Candidate survey responses
model CandidateResponse {
  id                String                  @id @default(uuid())
  surveyId          String                  @map("survey_id")
  survey            Survey                  @relation(fields: [surveyId], references: [id], onDelete: Cascade)
  candidateName     String                  @map("candidate_name")
  candidateEmail    String?                 @map("candidate_email")
  candidateParty    String?                 @map("candidate_party")
  candidateOffice   String?                 @map("candidate_office")
  candidateDistrict String?                 @map("candidate_district")
  officeTypeId      String?                 @map("office_type_id")
  officeType        OfficeType?             @relation(fields: [officeTypeId], references: [id])
  candidateState    String?                 @map("candidate_state") @db.Char(2)
  candidateCounty   String?                 @map("candidate_county")
  accessToken       String                  @map("access_token")
  status            CandidateResponseStatus @default(pending)
  totalScore        Decimal?                @map("total_score") @db.Decimal(5, 2)
  submittedAt       DateTime?               @map("submitted_at")
  createdAt         DateTime                @default(now()) @map("created_at")
  updatedAt         DateTime                @updatedAt @map("updated_at")

  answers           SurveyAnswer[]
  vetting           CandidateVetting?

  @@map("rlc_candidate_responses")
}

/// Individual survey answers
model SurveyAnswer {
  id                  String            @id @default(uuid())
  candidateResponseId String            @map("candidate_response_id")
  candidateResponse   CandidateResponse @relation(fields: [candidateResponseId], references: [id], onDelete: Cascade)
  questionId          String            @map("question_id")
  question            SurveyQuestion    @relation(fields: [questionId], references: [id], onDelete: Cascade)
  answer              String
  score               Decimal?          @db.Decimal(5, 2)

  @@map("rlc_survey_answers")
}

// ===========================================
// Phase 5: Liberty Scorecard & Action Center
// ===========================================

/// Legislators tracked for scorecard voting records
model Legislator {
  id                String              @id @default(uuid())
  legiscanPeopleId  Int?                @unique @map("legiscan_people_id")
  name              String
  party             String
  chamber           LegislativeChamber
  stateCode         String              @map("state_code")
  district          String?
  photoUrl          String?             @map("photo_url")
  currentScore      Decimal?            @map("current_score") @db.Decimal(5, 2)
  metadata          Json                @default("{}")
  createdAt         DateTime            @default(now()) @map("created_at")
  updatedAt         DateTime            @updatedAt @map("updated_at")

  votes                    ScorecardVote[]
  campaignParticipations   CampaignParticipation[]
  sessionScores            ScorecardLegislatorScore[]

  @@map("rlc_legislators")
}

/// Scorecard sessions (e.g. "118th Congress" or "2025 Texas Session")
model ScorecardSession {
  id            String                  @id @default(uuid())
  name          String
  slug          String                  @unique
  jurisdiction  Jurisdiction            @default(federal)
  stateCode     String?                 @map("state_code")
  charterId     String?                 @map("charter_id")
  charter       Charter?                @relation(fields: [charterId], references: [id])
  sessionYear   Int                     @map("session_year")
  status        ScorecardSessionStatus  @default(draft)
  description   String?                 @db.Text
  chamber       LegislativeChamber?     @map("chamber")
  partyFilter   String?                 @map("party_filter")
  absencePenaltyThreshold Int           @default(3) @map("absence_penalty_threshold")
  createdBy     String?                 @map("created_by")
  creator          Contact?                 @relation("ScorecardCreator", fields: [createdBy], references: [id])
  createdAt     DateTime                @default(now()) @map("created_at")
  updatedAt     DateTime                @updatedAt @map("updated_at")

  bills              ScorecardBill[]
  legislatorScores   ScorecardLegislatorScore[]

  @@map("rlc_scorecard_sessions")
}

/// Bills tracked in a scorecard session
model ScorecardBill {
  id                   String              @id @default(uuid())
  sessionId            String              @map("session_id")
  session              ScorecardSession    @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  legiscanBillId       Int?                @map("legiscan_bill_id")
  billNumber           String              @map("bill_number")
  title                String
  description          String?             @db.Text
  libertyPosition      LibertyPosition     @map("liberty_position")
  aiSuggestedPosition  LibertyPosition?    @map("ai_suggested_position")
  aiAnalysis           String?             @map("ai_analysis") @db.Text
  category             String              @default("other")
  weight               Decimal             @default(1.0) @db.Decimal(3, 1)
  voteDate             DateTime?           @map("vote_date") @db.Date
  billStatus           BillTrackingStatus  @default(tracking) @map("bill_status")
  legiscanRollCallId   Int?                @map("legiscan_roll_call_id")
  sortOrder            Int                 @default(0) @map("sort_order")
  isBonus              Boolean             @default(false) @map("is_bonus")
  bonusPointValue      Decimal             @default(0) @map("bonus_point_value") @db.Decimal(3, 1)
  voteResultSummary    String?             @map("vote_result_summary") @db.Text
  createdAt            DateTime            @default(now()) @map("created_at")
  updatedAt            DateTime            @updatedAt @map("updated_at")

  votes                ScorecardVote[]
  actionCampaigns      ActionCampaign[]

  @@map("rlc_scorecard_bills")
}

/// Individual legislator votes on scorecard bills
model ScorecardVote {
  id                 String        @id @default(uuid())
  billId             String        @map("bill_id")
  bill               ScorecardBill @relation(fields: [billId], references: [id], onDelete: Cascade)
  legislatorId       String        @map("legislator_id")
  legislator         Legislator    @relation(fields: [legislatorId], references: [id], onDelete: Cascade)
  vote               VoteChoice
  alignedWithLiberty Boolean       @map("aligned_with_liberty")
  sponsorshipRole    SponsorshipRole? @map("sponsorship_role")
  createdAt          DateTime      @default(now()) @map("created_at")

  @@unique([billId, legislatorId])
  @@index([billId])
  @@map("rlc_scorecard_votes")
}

/// Per-session computed scores for each legislator
model ScorecardLegislatorScore {
  id               String           @id @default(uuid())
  sessionId        String           @map("session_id")
  session          ScorecardSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  legislatorId     String           @map("legislator_id")
  legislator       Legislator       @relation(fields: [legislatorId], references: [id], onDelete: Cascade)
  votesAligned     Int              @default(0) @map("votes_aligned")
  totalBills       Int              @default(0) @map("total_bills")
  absences         Int              @default(0) @map("absences")
  bonusPoints      Decimal          @default(0) @map("bonus_points") @db.Decimal(5, 2)
  libertyScore     Decimal          @map("liberty_score") @db.Decimal(5, 2)
  createdAt        DateTime         @default(now()) @map("created_at")
  updatedAt        DateTime         @updatedAt @map("updated_at")

  @@unique([sessionId, legislatorId])
  @@index([sessionId])
  @@index([legislatorId])
  @@map("rlc_scorecard_legislator_scores")
}

/// Action Center campaigns for member advocacy
model ActionCampaign {
  id              String              @id @default(uuid())
  title           String
  slug            String              @unique
  description     String?             @db.Text
  billId          String?             @map("bill_id")
  bill            ScorecardBill?      @relation(fields: [billId], references: [id])
  charterId       String?             @map("charter_id")
  charter         Charter?            @relation(fields: [charterId], references: [id])
  targetChamber   LegislativeChamber? @map("target_chamber")
  targetStateCode String?             @map("target_state_code")
  messageTemplate String?             @map("message_template") @db.Text
  status          CampaignStatus      @default(draft)
  createdBy       String?             @map("created_by")
  creator          Contact?             @relation("CampaignCreator", fields: [createdBy], references: [id])
  startsAt        DateTime?           @map("starts_at")
  endsAt          DateTime?           @map("ends_at")
  createdAt       DateTime            @default(now()) @map("created_at")
  updatedAt       DateTime            @updatedAt @map("updated_at")

  participations  CampaignParticipation[]

  @@map("rlc_action_campaigns")
}

/// Tracks member participation in action campaigns
model CampaignParticipation {
  id           String          @id @default(uuid())
  campaignId   String          @map("campaign_id")
  campaign     ActionCampaign  @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  contactId    String          @map("contact_id")
  contact      Contact         @relation(fields: [contactId], references: [id])
  action       String
  legislatorId String?         @map("legislator_id")
  legislator   Legislator?     @relation(fields: [legislatorId], references: [id])
  metadata     Json            @default("{}")
  createdAt    DateTime        @default(now()) @map("created_at")

  @@unique([campaignId, contactId, action, legislatorId])
  @@map("rlc_campaign_participations")
}

// ===========================================
// Dues Sharing & Revenue Split
// ===========================================

/// Stripe Connect Express account for a charter (1:1)
model CharterStripeAccount {
  id                    String              @id @default(uuid())
  charterId             String              @unique @map("charter_id")
  charter               Charter             @relation(fields: [charterId], references: [id])
  stripeAccountId       String              @unique @map("stripe_account_id")
  status                StripeConnectStatus @default(not_started)
  chargesEnabled        Boolean             @default(false) @map("charges_enabled")
  payoutsEnabled        Boolean             @default(false) @map("payouts_enabled")
  onboardingCompletedAt DateTime?           @map("onboarding_completed_at")
  createdAt             DateTime            @default(now()) @map("created_at")
  updatedAt             DateTime            @updatedAt @map("updated_at")

  @@map("rlc_charter_stripe_accounts")
}

/// Disbursement preferences for a charter (1:1)
model CharterSplitConfig {
  id                 String             @id @default(uuid())
  charterId          String             @unique @map("charter_id")
  charter            Charter            @relation(fields: [charterId], references: [id])
  disbursementModel  DisbursementModel  @default(national_managed) @map("disbursement_model")
  isActive           Boolean            @default(true) @map("is_active")
  updatedById        String?            @map("updated_by_id")
  updatedBy        Contact?            @relation("SplitConfigUpdater", fields: [updatedById], references: [id])
  createdAt          DateTime           @default(now()) @map("created_at")
  updatedAt          DateTime           @updatedAt @map("updated_at")

  rules              CharterSplitRule[]

  @@map("rlc_charter_split_configs")
}

/// Individual percentage allocation to a sub-charter
model CharterSplitRule {
  id                  String             @id @default(uuid())
  configId            String             @map("config_id")
  config              CharterSplitConfig @relation(fields: [configId], references: [id], onDelete: Cascade)
  recipientCharterId  String             @map("recipient_charter_id")
  recipientCharter    Charter            @relation("SplitRuleRecipient", fields: [recipientCharterId], references: [id])
  percentage          Decimal            @db.Decimal(5, 2)
  sortOrder           Int                @default(0) @map("sort_order")
  isActive            Boolean            @default(true) @map("is_active")
  createdAt           DateTime           @default(now()) @map("created_at")
  updatedAt           DateTime           @updatedAt @map("updated_at")

  @@unique([configId, recipientCharterId])
  @@map("rlc_charter_split_rules")
}

/// Immutable audit trail: one row per recipient per payment
model SplitLedgerEntry {
  id                     String            @id @default(uuid())
  contributionId         String            @map("contribution_id")
  contribution           Contribution      @relation(fields: [contributionId], references: [id])
  sourceType             SplitSourceType   @map("source_type")
  recipientCharterId     String            @map("recipient_charter_id")
  recipientCharter       Charter           @relation("LedgerRecipient", fields: [recipientCharterId], references: [id])
  amount                 Decimal           @db.Decimal(10, 2)
  currency               String            @default("USD")
  status                 SplitLedgerStatus @default(pending)
  stripeTransferId       String?           @map("stripe_transfer_id")
  stripeTransferGroupId  String?           @map("stripe_transfer_group_id")
  transferredAt          DateTime?         @map("transferred_at")
  reversalOfId           String?           @map("reversal_of_id")
  reversalOf             SplitLedgerEntry? @relation("LedgerReversal", fields: [reversalOfId], references: [id])
  reversals              SplitLedgerEntry[] @relation("LedgerReversal")
  splitRuleSnapshot      Json              @default("{}") @map("split_rule_snapshot")
  createdAt              DateTime          @default(now()) @map("created_at")

  @@index([contributionId, recipientCharterId])
  @@index([recipientCharterId, status, createdAt])
  @@map("rlc_split_ledger_entries")
}

// ===========================================
// Candidate Vetting & Endorsement System
// ===========================================

/// Vetting committee definition
model CandidateVettingCommittee {
  id        String   @id @default(uuid())
  name      String
  isActive  Boolean  @default(true) @map("is_active")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  members  CandidateVettingCommitteeMember[]
  vettings CandidateVetting[]

  @@map("rlc_candidate_vetting_committees")
}

/// Committee membership (who's on the committee, with role)
model CandidateVettingCommitteeMember {
  id          String        @id @default(uuid())
  committeeId String        @map("committee_id")
  committee   CandidateVettingCommittee @relation(fields: [committeeId], references: [id], onDelete: Cascade)
  contactId   String        @map("contact_id")
  contact     Contact       @relation(fields: [contactId], references: [id])
  role        CommitteeRole @default(committee_member)
  isActive    Boolean       @default(true) @map("is_active")
  joinedAt    DateTime      @default(now()) @map("joined_at")
  createdAt   DateTime      @default(now()) @map("created_at")
  updatedAt   DateTime      @updatedAt @map("updated_at")

  sectionAssignments CandidateVettingSectionAssignment[]

  @@unique([committeeId, contactId])
  @@map("rlc_candidate_vetting_committee_members")
}

/// Master vetting record per candidate being vetted
model CandidateVetting {
  id                  String               @id @default(uuid())
  candidateResponseId String               @unique @map("candidate_response_id")
  candidateResponse   CandidateResponse    @relation(fields: [candidateResponseId], references: [id])
  committeeId         String?              @map("committee_id")
  committee           CandidateVettingCommittee? @relation(fields: [committeeId], references: [id])
  stage               VettingStage         @default(survey_submitted)

  // Election info (denormalized for quick access)
  candidateName       String               @map("candidate_name")
  candidateOffice     String?              @map("candidate_office")
  candidateDistrict   String?              @map("candidate_district")
  candidateState      String?              @map("candidate_state")
  candidateParty      String?              @map("candidate_party")
  officeTypeId        String?              @map("office_type_id")
  officeType          OfficeType?          @relation(fields: [officeTypeId], references: [id])
  charterId           String?              @map("charter_id") // denormalized from survey for pipeline scoping

  // Deadline reference
  electionDeadlineId  String?              @map("election_deadline_id")
  electionDeadline    CandidateElectionDeadline? @relation(fields: [electionDeadlineId], references: [id])

  // District data reference
  districtDataId      String?              @map("district_data_id")
  districtData        CandidateDistrictData? @relation(fields: [districtDataId], references: [id])

  // Interview
  interviewDate       DateTime?            @map("interview_date")
  interviewNotes      String?              @map("interview_notes") @db.Text
  interviewers        String[]             @default([])

  // Recommendation (committee chair)
  recommendation      VettingRecommendation? @map("recommendation")
  recommendationNotes String?              @map("recommendation_notes") @db.Text
  recommendedAt       DateTime?            @map("recommended_at")

  // Final result
  endorsementResult   VettingRecommendation? @map("endorsement_result")
  endorsedAt          DateTime?            @map("endorsed_at")

  metadata            Json                 @default("{}")
  createdAt           DateTime             @default(now()) @map("created_at")
  updatedAt           DateTime             @updatedAt @map("updated_at")

  // Relations
  reportSections      CandidateVettingReportSection[]
  opponents           CandidateVettingOpponent[]
  boardVotes          CandidateVettingBoardVote[]
  digitalAudits       CandidateDigitalAudit[]

  @@index([stage])
  @@index([candidateState])
  @@map("rlc_candidate_vettings")
}

/// Report section data (one row per section per vetting)
model CandidateVettingReportSection {
  id          String                    @id @default(uuid())
  vettingId   String                    @map("vetting_id")
  vetting     CandidateVetting          @relation(fields: [vettingId], references: [id], onDelete: Cascade)
  section     VettingReportSectionType
  status      VettingSectionStatus      @default(section_not_started)
  data        Json                      @default("{}")
  aiDraftData Json?                     @map("ai_draft_data")
  notes       String?                   @db.Text
  createdAt   DateTime                  @default(now()) @map("created_at")
  updatedAt   DateTime                  @updatedAt @map("updated_at")

  assignments CandidateVettingSectionAssignment[]

  @@unique([vettingId, section])
  @@map("rlc_candidate_vetting_report_sections")
}

/// Section assignment (which member researches which section)
model CandidateVettingSectionAssignment {
  id               String                        @id @default(uuid())
  sectionId        String                        @map("section_id")
  section          CandidateVettingReportSection  @relation(fields: [sectionId], references: [id], onDelete: Cascade)
  committeeMemberId String                       @map("committee_member_id")
  committeeMember  CandidateVettingCommitteeMember @relation(fields: [committeeMemberId], references: [id])
  assignedById     String?                       @map("assigned_by_id")
  assignedBy       Contact?                      @relation(fields: [assignedById], references: [id])
  assignedAt       DateTime                      @default(now()) @map("assigned_at")

  @@unique([sectionId, committeeMemberId])
  @@map("rlc_candidate_vetting_section_assignments")
}

/// Opponent records for a vetting
model CandidateVettingOpponent {
  id              String           @id @default(uuid())
  vettingId       String           @map("vetting_id")
  vetting         CandidateVetting @relation(fields: [vettingId], references: [id], onDelete: Cascade)
  name            String
  party           String?
  isIncumbent     Boolean          @default(false) @map("is_incumbent")
  background      String?          @db.Text
  credibility     String?          @db.Text
  fundraising     Json?
  endorsements    String[]         @default([])
  socialLinks     Json?            @map("social_links")
  photoUrl        String?          @map("photo_url")
  metadata        Json             @default("{}")
  createdAt       DateTime         @default(now()) @map("created_at")
  updatedAt       DateTime         @updatedAt @map("updated_at")

  @@map("rlc_candidate_vetting_opponents")
}

/// Board vote on a vetting (one per board member)
model CandidateVettingBoardVote {
  id        String           @id @default(uuid())
  vettingId String           @map("vetting_id")
  vetting   CandidateVetting @relation(fields: [vettingId], references: [id], onDelete: Cascade)
  voterId   String           @map("voter_id")
  voter     Contact          @relation(fields: [voterId], references: [id])
  vote      BoardVoteChoice
  notes     String?          @db.Text
  votedAt   DateTime         @default(now()) @map("voted_at")

  @@unique([vettingId, voterId])
  @@map("rlc_candidate_vetting_board_votes")
}

/// Election deadlines by state/cycle/office type (shared reference data)
model CandidateElectionDeadline {
  id                     String    @id @default(uuid())
  stateCode              String    @map("state_code") @db.Char(2)
  cycleYear              Int       @map("cycle_year")
  officeType             String    @map("office_type")
  primaryDate            DateTime? @map("primary_date") @db.Date
  primaryRunoffDate      DateTime? @map("primary_runoff_date") @db.Date
  generalDate            DateTime? @map("general_date") @db.Date
  generalRunoffDate      DateTime? @map("general_runoff_date") @db.Date
  filingDeadline         DateTime? @map("filing_deadline") @db.Date
  notes                  String?   @db.Text
  createdAt              DateTime  @default(now()) @map("created_at")
  updatedAt              DateTime  @updatedAt @map("updated_at")

  vettings CandidateVetting[]

  @@unique([stateCode, cycleYear, officeType])
  @@map("rlc_candidate_election_deadlines")
}

/// District demographics and electoral data (shared across candidates in same district)
model CandidateDistrictData {
  id                 String    @id @default(uuid())
  stateCode          String    @map("state_code") @db.Char(2)
  districtId         String    @map("district_id")
  officeType         String    @map("office_type")
  cookPvi            String?   @map("cook_pvi")
  population         Int?
  partyRegistration  Json?     @map("party_registration")
  municipalities     String[]  @default([])
  counties           String[]  @default([])
  overlappingDistricts String[] @default([]) @map("overlapping_districts")
  electoralHistory   Json?     @map("electoral_history")
  mapUrl             String?   @map("map_url")
  metadata           Json      @default("{}")
  createdAt          DateTime  @default(now()) @map("created_at")
  updatedAt          DateTime  @updatedAt @map("updated_at")

  vettings CandidateVetting[]

  @@unique([stateCode, districtId, officeType])
  @@map("rlc_candidate_district_data")
}

/// Digital presence audit results per vetting
model CandidateDigitalAudit {
  id                     String      @id @default(uuid())
  vettingId              String      @map("vetting_id")
  vetting                CandidateVetting @relation(fields: [vettingId], references: [id], onDelete: Cascade)
  status                 AuditStatus @default(audit_pending)
  startedAt              DateTime?   @map("started_at")
  completedAt            DateTime?   @map("completed_at")
  triggeredById          String?     @map("triggered_by_id")
  triggeredBy            Contact?    @relation("AuditTriggeredBy", fields: [triggeredById], references: [id])

  // Candidate audit results
  candidateOverallScore  Int?        @map("candidate_overall_score")
  candidateGrade         String?     @map("candidate_grade")
  candidateScoreBreakdown Json?      @map("candidate_score_breakdown")
  candidateRisks         Json?       @map("candidate_risks")

  // Opponent audit summaries
  opponentAudits         Json?       @map("opponent_audits")

  // Raw data
  discoveryLog           Json?       @map("discovery_log")
  screenshotsManifest    Json?       @map("screenshots_manifest")
  errorMessage           String?     @map("error_message") @db.Text
  metadata               Json        @default("{}")
  createdAt              DateTime    @default(now()) @map("created_at")
  updatedAt              DateTime    @updatedAt @map("updated_at")

  platforms CandidateAuditPlatform[]

  @@index([vettingId])
  @@map("rlc_candidate_digital_audits")
}

/// Normalized per-platform records from the digital audit
model CandidateAuditPlatform {
  id                   String             @id @default(uuid())
  auditId              String             @map("audit_id")
  audit                CandidateDigitalAudit @relation(fields: [auditId], references: [id], onDelete: Cascade)
  entityType           String             @map("entity_type")
  entityName           String             @map("entity_name")
  platformName         String             @map("platform_name")
  platformUrl          String?            @map("platform_url")
  confidenceScore      Decimal?           @map("confidence_score") @db.Decimal(3, 2)
  discoveryMethod      String?            @map("discovery_method")
  activityStatus       String?            @map("activity_status")
  lastActivityDate     DateTime?          @map("last_activity_date")
  followers            Int?
  engagementRate       Decimal?           @map("engagement_rate") @db.Decimal(5, 2)
  screenshotDesktopUrl String?            @map("screenshot_desktop_url")
  screenshotMobileUrl  String?            @map("screenshot_mobile_url")
  scorePresence        Int?               @map("score_presence")
  scoreConsistency     Int?               @map("score_consistency")
  scoreQuality         Int?               @map("score_quality")
  scoreAccessibility   Int?               @map("score_accessibility")
  totalScore           Int?               @map("total_score")
  grade                String?
  contactMethods       Json?              @map("contact_methods")
  metadata             Json               @default("{}")
  createdAt            DateTime           @default(now()) @map("created_at")
  updatedAt            DateTime           @updatedAt @map("updated_at")

  @@index([auditId, entityType])
  @@map("rlc_candidate_audit_platforms")
}

/// Webhook Events (idempotency tracking for Stripe webhooks)
model WebhookEvent {
  id            String   @id @default(uuid())
  stripeEventId String   @unique @map("stripe_event_id")
  eventType     String   @map("event_type")
  processedAt   DateTime @default(now()) @map("processed_at")

  @@map("rlc_webhook_events")
}
